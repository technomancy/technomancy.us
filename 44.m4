<!DOCTYPE html> <!-*- html -*-->
define(__timestamp, 2006-04-24T20:32:32Z)dnl
define(__title, `arbis and kaizen')dnl
define(__id, 44)dnl
include(header.html)
    <p>OK,  so I've been playing with dynamic languages a lot. In the past year I've somehow been able to get away with programming in Ruby and Lisp almost exclusively. It's a rather refreshing feeling,  especially after wasting so much time with C++ in university. The funny thing is,  a good deal of the software I actually <i>use</i> is written in C.</p>
<p>My recent excursions elisp have made me realize that working in a dynamic language allows for an environment that you can mold and shape on the fly to suit your whims. Such a system allows you to grow more productive the more you use it,  not only because you learn more and more about the environment,  but because the environment also reciprocates and '<a href='http://dev.technomancy.us/phil/browser/dotfiles/.emacs'>learns</a>' more about you.</p>
<p>This is technically possible with programs written in C (or any other non-dynamic language) if you are fairly familiar with the source,  but the feedback cycle is so much longer due to compilation that you simply wouldn't bother with small improvements. You're also stuck with the problem of what to do with your customizations. If they're the sort of thing everyone would like,  then great,  you submit a patch. If they're a matter of taste and personal opinion,  you might be able to make it an <a href='http://ometer.com/free-software-ui.html'>optional preference</a> if you're lucky and don't mind cluttering up the software. But otherwise when the next version comes out,  it won't have your customizations.</p>
<p>But this is really only even relevant if you've already invested a lot in C. I can't count the number of times I've felt brave and checked something out of the GNOME CVS or the like,  somehow under the impression that I'd do some serious hacking or at least grok it on some level. But the outcome was always the same&mdash;I would soon realize that getting reacquainted with C was one of the last things I'd like to be doing with my time.</p>
<p>I've been able to get away with doing a lot of my everyday tasks in Emacs,  and Emacs rewards me for doing so in a way. However,  it can't do everything. It does a great job at simple web browsing with w3m-mode,  but there's simply no way it can render CSS properly,  and ECMAScript is out of the question. (From what I gather the problem with CSS is that the Emacs rendering engine is showing its age.) This lead me to play around a bit with the <a href='http://www.stud.uni-karlsruhe.de/~unk6/closure/'>Closure</a> web browser,  but it's not exactly what you'd call mature.</p>
<p><a href='http://www.loudthinking.com/arc/000557.html'>Someone recently said</a> that reuse is vastly overrated: </p>
<blockquote>Finally,  the new economics of dynamic languages like Ruby simply makes reuse a lot less attractive. Since the cost of producing new,  original code is so much lower,  the demands on reuse are that much greater. And usually that means it'll take more time to reuse something than it'll take to create it from scratch.</blockquote>
<p>So why bounce around between Epiphany,  Firefox,  and Closure? Ruby's got <a href='http://ruby-gnome2.sourceforge.jp/hiki.cgi?RubyZilla'> what you need to make a browser</a>. It's just a matter of tying together the Gecko components in GTK and then customizing to your heart's content. I've <a href='http://dev.technomancy.us/phil/browser/arbis'>started</a> with a little project called Arbis as an experiment; we'll see how it goes. It's already faster than both Firefox and Epiphany. I suppose the biggest question is how 'deep' the ruby gecko bindings go&mdash;if it's fairly surface-level it may not be useful for anything more than a toy.</p>
<!--    <p>So all that to say that I've started to see static programs in a different light. I have <a href='http://gaim.sf.net'>Gaim</a> open right now,  and on some level it's bothering me. Sure it's nifty because it has nice icons and integrates with the panel more nicely than Emacs would,  but it's just so static. It's compiled and set in stone; there's not much I can do about it. If I want to make it better I'd have to hope someone had written a plugin for what I'm thinking of. Contrast this to rcirc in Emacs,  where all that's needed is just poke some elisp and eval on the fly.</p>--> <p><b>Update</b>: while embedding a gecko frame in Ruby is possible, it's not really useful since none of the functionality inside the page is exposed to Ruby; just basic back/forward navigation.</p>
include(footer.html)
